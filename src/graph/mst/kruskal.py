from typing import Iterator, Optional

from graph import Edge, Vertex, timeit, Graph
from graph.mst.abstractMst import MST


class Bucket():
    """
    Mark bucket helper.

    This class is a helper to check which vertexes are marked for kruskal's
    algorithm. It keeps track on which vertexes are marked for which components
    and maintains dictionaries for looking up both status and component
    identifier quickly.
    """

    def __init__(self):
        """
        Constructor.
        """
        self._mark = {}
        self._comp = {}
        self._counter = 0

    def __contains__(self, v: Vertex) -> bool:
        """
        Check if a vertex is marked yet.


        :param v: The vertex to be checked.

        :returns: Whether ``v`` is marked or not.
        """
        return (v.value in self._mark)

    def add(self, v: Vertex, comp: int) -> None:
        """
        Mark a vertex as visited.


        :param v: The vertex to be marked.
        :param comp: The component ``v`` belongs to for marking.
        """
        self._mark[v.value] = comp
        if comp in self._comp:
            self._comp[comp].add(v.value)
        else:
            self._comp[comp] = set([v.value])

    def combine(self, a, b) -> None:
        """
        Combine two components.

        This  method combines two components in the marked set, so kruskal's
        algorithm can reliably determine which vertexes can be ignored for
        further processing.


        :param a: The first component.
        :param b: The second component.
        """
        # If component B has less edges than component A, switch both to always
        # merge less edges into a smaller component and spare operations.
        if len(self._comp[a]) < len(self._comp[b]):
            a, b = b, a

        # Merge component B into A and remove B from the marked dataset, as its
        # just A remaining after this operation.
        for v in self._comp[b]:
            self._comp[a].add(v)
            self._mark[v] = a
        self._comp.pop(b)

    def comp(self, v: Vertex) -> Optional[int]:
        """
        Get the component of a vertex.


        :returns: The vertex's component identifier or :py:class:`None`, if the
            vertex is not marked yet.
        """
        if v in self:
            return self._mark[v.value]

    def compOrNext(self, a: Vertex, b: Vertex) -> int:
        """
        Get the first matching component of vertexes or get a new one.

        This method checks vertexes ``a`` and ``b`` for components and get the
        first one that's not :py:class:`None`. If both are :py:class:`None`, a
        new component identifier will be generated and incremented on subsequent
        calls.


        :param a: The first vertex.
        :param b: The second vertex.

        :returns: The component of the first or second vertex, or a new one, if
            both are not marked yet.
        """
        # Check the components of both vertexes and get the one that's not None.
        compA = self.comp(a)
        compB = self.comp(b)
        if compA is not None:
            return compA
        elif compB is not None:
            return compB

        # If both vertexes are not marked yet, a new component identifier is
        # needed and generated by incrementing the bucket's global counter.
        else:
            self._counter += 1
            return self._counter


class Kruskal(MST):
    mst = Graph()
    def __call__(self):
        return self._kruskal_cost()

    def _kruskal(self) -> Iterator[Edge]:
        """
        Run the Kruskal algorithm on the graph to get a minimal spanning tree.


        :returns: Iterator for the minimal spanning tree's edges.
        """
        # Sort all edges of the graph by weight and iterate over them to build
        # the minimal spanning tree by kruskal's algorithm.
        mark = Bucket()
        edge_list = []
        [edge_list.extend(list(x.values())) for x in list(self.graph.edges.values())]
        for e in sorted(edge_list):
            # If at least one vertex of the edge is not marked yet, it can be
            # added to the marked set easily.
            if e.start not in mark or e.end not in mark:
                # Get the component, this edge belongs to. For vertexes unknown
                # to the marked set, the following function will generate a new
                # component ID. For those known the existing ID will be returned
                # instead, allowing the new vertex to be connected to existing
                # components.
                c = mark.compOrNext(e.start, e.end)

                # Mark the vertexes as visited and yield the next edge of the
                # minimal spanning tree.
                mark.add(e.start, c)
                mark.add(e.end, c)
                yield e

            # If both vertexes already are marked, check if they belong to the
            # same component. If they don't, this edge is yet unknown and can be
            # used to merge both components to a single spanning tree.
            else:
                compA = mark.comp(e.start)
                compB = mark.comp(e.end)
                if compA != compB:
                    mark.combine(compA, compB)
                    yield e

    @timeit
    def _kruskal_cost(self) -> float:
        """
        Run the Kruskal algorithm and get its runtime.

        This method runs the kruskal algorithm on the object's loaded graph and
        returns the runtime needed to calculate the minimal spanning tree.


        :returns: The algorithm's runtime.
        """
        return sum(map(lambda e: e.weight, self._kruskal()))

    @timeit
    def get_mst(self) -> Graph:
        """
        Run the Kruskal algorithm and get the found MST

        :return: A Graph object that contains the found MST
        """
        self.mst = Graph(self.graph.vertex_count)
        list(map(self.mst.add_existing_edge, self._kruskal()))
        return self.mst
